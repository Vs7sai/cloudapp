module.exports = [
  {
    "id": 1,
    "text": "What is Docker?",
    "textSize": 24,
    "explanation": "Docker is a containerization platform that allows you to package applications and their dependencies into lightweight, portable **containers** that can run consistently across different environments."
  },
  {
    "id": 2,
    "text": "What is the difference between a Docker image and a container?",
    "textSize": 20,
    "explanation": "A **Docker image** is a read-only template used to create containers. A **container** is a running instance of an image. Think of an image as a class blueprint and a container as an object instance of that class."
  },
  {
    "id": 3,
    "text": "What is a Dockerfile?",
    "textSize": 24,
    "explanation": "A **Dockerfile** is a text file containing a series of instructions used to build a Docker image. It defines the base image, dependencies, configuration, and commands needed to create the application environment.\n\n**Example Dockerfile snippet:**\n```dockerfile\nFROM alpine:latest\nWORKDIR /app\nCOPY . .\nRUN apk add --no-cache nodejs\nCMD [\"node\", \"app.js\"]\n```"
  },
  {
    "id": 4,
    "text": "Explain Docker layers.",
    "textSize": 24,
    "explanation": "Docker images are built in **layers**, where each instruction in a Dockerfile creates a new layer. Layers are cached and reused, making builds faster and more efficient. Only changed layers need to be rebuilt, which saves time and disk space.\n\n**Example (each line creates a layer):**\n```dockerfile\nFROM ubuntu:22.04  # Layer 1\nRUN apt-get update # Layer 2\nRUN apt-get install -y git # Layer 3\nCOPY . /app       # Layer 4\n```"
  },
  {
    "id": 5,
    "text": "What is Docker Compose?",
    "textSize": 24,
    "explanation": "Docker Compose is a tool for defining and running **multi-container Docker applications**. It uses a single YAML file (`docker-compose.yml`) to configure all application services, networks, and volumes, simplifying their orchestration and management.\n\n**Example `docker-compose.yml`:**\n```yaml\nversion: '3.8'\nservices:\n  web:\n    image: nginx:alpine\n    ports:\n      - '80:80'\n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_DB: mydatabase\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n```\nTo run this, you'd use `docker compose up -d`."
  },
  {
    "id": 6,
    "text": "How do you build a Docker image?",
    "textSize": 24,
    "explanation": "You build a Docker image using the `docker build` command. You typically use the `-t` flag to **tag** (name and version) the image and specify the build context (usually `.` for the current directory where the Dockerfile is located), e.g., `docker build -t myapp:1.0 .`\n\n**Example Command:**\n```bash\ndocker build -t my-web-app:v1.0 .\n```"
  },
  {
    "id": 7,
    "text": "How do you run a Docker container?",
    "textSize": 24,
    "explanation": "You run a Docker container from an image using the `docker run` command. Common options include `-d` for **detached mode** (background), `-p` for **port mapping** (e.g., `-p 8080:80`), and `--name` to assign a memorable name.\n\n**Example Command:**\n```bash\ndocker run -d -p 8080:80 --name my-nginx-container nginx:latest\n```"
  },
  {
    "id": 8,
    "text": "What are Docker volumes and why are they used?",
    "textSize": 20,
    "explanation": "Docker **volumes** are the preferred way to **persist data** generated by and used by Docker containers. They store data on the host filesystem, independent of the container's lifecycle. This ensures data isn't lost when a container is removed or updated and allows data to be shared between containers.\n\n**Example creating and using a named volume:**\n```bash\ndocker volume create my_app_data\ndocker run -d -v my_app_data:/var/lib/mysql --name my-db mysql:8.0\n```"
  },
  {
    "id": 9,
    "text": "What's the difference between `COPY` and `ADD` in a Dockerfile?",
    "textSize": 20,
    "explanation": "`COPY` is used to copy files or directories from the build context to the image. `ADD` has the same functionality but can also **automatically extract compressed archives** (like `.tar.gz`) and fetch files from **remote URLs**. `COPY` is generally preferred for clarity unless `ADD`'s extra features are specifically needed.\n\n**Example `COPY`:**\n```dockerfile\nCOPY ./src /app/src\n```\n**Example `ADD` (with tar extraction and URL):**\n```dockerfile\nADD myarchive.tar.gz /app/\nADD [https://example.com/config.json](https://example.com/config.json) /etc/myapp/\n```"
  },
  {
    "id": 10,
    "text": "What is Docker Hub?",
    "textSize": 24,
    "explanation": "Docker Hub is the official **cloud-based Docker Registry**. It's a central repository for storing, discovering, and sharing Docker images. You can find official images (like `nginx`, `python`) and host your own public or private images there."
  },
  {
    "id": 11,
    "text": "How do you push a Docker image to Docker Hub?",
    "textSize": 20,
    "explanation": "First, you need to `docker login`. Then, **tag your image** with your Docker Hub username and repository name (e.g., `docker tag myapp username/myapp:latest`). Finally, `docker push` the tagged image to the registry.\n\n**Example Commands:**\n```bash\ndocker login\ndocker tag my-local-app:v1 myusername/my-repo:v1\ndocker push myusername/my-repo:v1\n```"
  },
  {
    "id": 12,
    "text": "Explain Docker networks.",
    "textSize": 24,
    "explanation": "Docker networks allow containers to communicate with each other and with the host machine. The default network is `bridge`, which creates a private network on the host. You can also create **custom bridge networks** for better isolation and service discovery, or use `host` network mode for direct host access.\n\n**Example creating a custom network and attaching containers:**\n```bash\ndocker network create my-app-net\ndocker run -d --network my-app-net --name web-server my-web-image\ndocker run -d --network my-app-net --name db-server my-db-image\n```\nContainers `web-server` and `db-server` can now communicate using their names."
  },
  {
    "id": 13,
    "text": "What is `EXPOSE` in a Dockerfile?",
    "textSize": 24,
    "explanation": "The `EXPOSE` instruction in a Dockerfile serves as **documentation** to indicate which ports the application inside the container will listen on at runtime. It **does not actually publish** the port. To make the port accessible from the host, you still need to explicitly map it using the `-p` flag with `docker run`.\n\n**Dockerfile Snippet:**\n```dockerfile\nEXPOSE 8080\n```\n**Running the container to publish the port:**\n```bash\ndocker run -p 80:8080 my-image\n```"
  },
  {
    "id": 14,
    "text": "What is the purpose of `.dockerignore` file?",
    "textSize": 20,
    "explanation": "A `.dockerignore` file specifies files and directories that should be **excluded from the build context** when Docker sends it to the Docker Daemon. This reduces the build context size, speeds up builds, and prevents sensitive or unnecessary files from being included in the image.\n\n**Example `.dockerignore` content:**\n```\nnode_modules/\n.git/\n*.log\ntmp/\n```"
  },
  {
    "id": 15,
    "text": "What's the difference between `CMD` and `ENTRYPOINT` in a Dockerfile?",
    "textSize": 20,
    "explanation": "`CMD` defines the **default command or arguments** that will be executed when a container starts. It can be easily overridden when running `docker run`. `ENTRYPOINT` defines the **primary executable** that will always run, and `CMD` then provides its default arguments. `ENTRYPOINT` is harder to override and is used to make a container behave like an executable.\n\n**Example 1: CMD as default command**\n```dockerfile\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n(Run with `docker run my-nginx-image` or override with `docker run my-nginx-image echo 'Hello'`)\n\n**Example 2: ENTRYPOINT with CMD as arguments**\n```dockerfile\nENTRYPOINT [\"java\", \"-jar\", \"/app/myapp.jar\"]\nCMD [\"--spring.profiles.active=prod\"]\n```\n(Runs `java -jar /app/myapp.jar --spring.profiles.active=prod` by default. Can override args with `docker run my-java-app --spring.profiles.active=dev`)"
  },
  {
    "id": 16,
    "text": "How do you get a shell inside a running Docker container?",
    "textSize": 20,
    "explanation": "You can use the `docker exec` command to run a command inside a running container. To get an interactive shell, you'd use `docker exec -it <container_name_or_id> bash` (or `sh`), where `-i` keeps STDIN open and `-t` allocates a pseudo-TTY.\n\n**Example Command:**\n```bash\ndocker exec -it my-web-container bash\n```"
  },
  {
    "id": 17,
    "text": "How do you check the logs of a Docker container?",
    "textSize": 20,
    "explanation": "You can view the logs of a container using the `docker logs <container_name_or_id>` command. To stream logs in real-time, you can add the `-f` (follow) flag: `docker logs -f <container_name_or_id>`.\n\n**Example Commands:**\n```bash\ndocker logs my-app-container           # View all logs\ndocker logs -f my-app-container        # Follow logs in real-time\ndocker logs --tail 50 my-app-container # View last 50 lines\n```"
  },
  {
    "id": 18,
    "text": "What is Docker Swarm?",
    "textSize": 24,
    "explanation": "Docker Swarm is Docker's **native orchestration tool** for managing a cluster of Docker engines (nodes) as a single virtual host. It provides features like service discovery, scaling, load balancing, and high availability for containerized applications, making it easier to deploy and manage applications in a production environment.\n\n**Example Swarm initialization and service creation:**\n```bash\ndocker swarm init --advertise-addr <MANAGER_IP>\ndocker service create --name my-web-service --replicas 3 -p 80:80 my-web-image\n```"
  },
  {
    "id": 19,
    "text": "Explain multi-stage builds in Docker.",
    "textSize": 24,
    "explanation": "**Multi-stage builds** allow you to create smaller, more efficient Docker images by using multiple `FROM` instructions in a single Dockerfile. You perform build-time operations (like compiling code) in an initial stage and then copy only the necessary artifacts to a smaller, final runtime stage, discarding all build dependencies.\n\n**Example Dockerfile with multi-stage build:**\n```dockerfile\n# Stage 1: Build the application\nFROM node:18-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build # Compiles app into /app/dist\n\n# Stage 2: Create the final, lightweight image\nFROM nginx:alpine\nCOPY --from=builder /app/dist /usr/share/nginx/html # Copy only compiled assets\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```"
  },
  {
    "id": 20,
    "text": "How can you limit the resources (CPU, memory) a Docker container can use?",
    "textSize": 18,
    "explanation": "You can limit container resources using flags with the `docker run` command. This is crucial for preventing a single container from monopolizing host resources.\n\n**Example Commands:**\n* **CPU Limit (1.5 cores):**\n    ```bash\n    docker run --cpus=1.5 myapp-image\n    ```\n* **Memory Limit (512 MB) and Swap (1 GB total):**\n    ```bash\n    docker run --memory=512m --memory-swap=1g myapp-image\n    ```"
  },
  {
    "id": 21,
    "text": "What is `HEALTHCHECK` in a Dockerfile?",
    "textSize": 24,
    "explanation": "The `HEALTHCHECK` instruction defines a command that Docker should run periodically inside the container to **determine if the application is healthy and responsive**. This helps orchestrators like Docker Swarm or Kubernetes know when to restart an unhealthy container, improving application reliability.\n\n**Example Dockerfile `HEALTHCHECK`:**\n```dockerfile\nHEALTHCHECK --interval=30s --timeout=10s --retries=3 \\\n  CMD curl -f http://localhost/health || exit 1\n```\n(This checks `http://localhost/health` every 30s, fails if no response in 10s, marks unhealthy after 3 failures.)"
  },
  {
    "id": 22,
    "text": "What is the command to stop all running Docker containers?",
    "textSize": 20,
    "explanation": "To stop all running Docker containers, you can combine `docker ps -aq` (which lists all running container IDs) with `docker stop`.\n\n**Command:**\n```bash\ndocker stop $(docker ps -aq)\n```"
  },
  {
    "id": 23,
    "text": "How do you remove all stopped Docker containers?",
    "textSize": 20,
    "explanation": "To remove all stopped Docker containers, you can use `docker rm` with a filter. A more common and recommended approach for general cleanup is `docker container prune`.\n\n**Command to remove only exited containers:**\n```bash\ndocker rm $(docker ps -aq --filter status=exited)\n```\n**Recommended command for general container cleanup:**\n```bash\ndocker container prune\n```"
  },
  {
    "id": 24,
    "text": "What is a Docker Registry vs. Docker Hub?",
    "textSize": 20,
    "explanation": "A **Docker Registry** is a generic term for a service that stores and distributes Docker images. **Docker Hub** is the *default public Docker Registry* provided by Docker Inc., where many official and community images are hosted. You can also run private Docker Registries."
  },
  {
    "id": 25,
    "text": "What is a Docker volume driver?",
    "textSize": 24,
    "explanation": "A Docker **volume driver** is a plugin that integrates Docker with external storage systems. This allows Docker volumes to be stored on network storage, cloud storage, or other specialized storage solutions, providing more robust persistence, backup, and high-availability options for container data."
  },
  {
    "id": 26,
    "text": "How do you inspect a Docker container or image?",
    "textSize": 20,
    "explanation": "You can use the `docker inspect` command followed by the container name/ID or image name/ID. This provides detailed low-level information in JSON format about its configuration, network settings, volumes, and more.\n\n**Example Commands:**\n```bash\ndocker inspect my-running-container\ndocker inspect nginx:latest\n```"
  },
  {
    "id": 27,
    "text": "What is Dockerfile `ARG` instruction?",
    "textSize": 24,
    "explanation": "The `ARG` instruction defines a **build-time variable** that users can pass to the builder with the `docker build --build-arg <varname>=<value>` flag. Unlike `ENV`, `ARG` variables are not persistent in the final image's environment, only available during the build process.\n\n**Dockerfile Snippet:**\n```dockerfile\nARG VERSION=1.0\nRUN echo \"Building version $VERSION\"\n```\n**Building with an ARG value:**\n```bash\ndocker build --build-arg VERSION=2.0 -t myapp:2.0 .\n```"
  },
  {
    "id": 28,
    "text": "What is `ONBUILD` instruction in a Dockerfile?",
    "textSize": 20,
    "explanation": "The `ONBUILD` instruction adds a **trigger instruction** to an image. When this image is used as a base image for another build (`FROM this_image`), the `ONBUILD` instructions are executed by the downstream build *before* any instructions in the downstream Dockerfile. It's useful for creating 'builder' images that automatically set up common build tasks.\n\n**Base Dockerfile (defines the trigger):**\n```dockerfile\nFROM alpine\nONBUILD COPY . /app/source\nONBUILD RUN /app/source/setup.sh\n```\n**Downstream Dockerfile (triggers the ONBUILD instructions):**\n```dockerfile\nFROM my-base-image:latest # This will run the ONBUILD instructions from my-base-image\nCOPY config.txt /app/config.txt\n```"
  },
  {
    "id": 29,
    "text": "How do you tag an existing Docker image?",
    "textSize": 24,
    "explanation": "You can tag an existing local Docker image using the `docker tag` command. This creates an alias or a new reference to an existing image ID.\n\n**Command:**\n```bash\ndocker tag source_image_name:source_tag target_image_name:new_tag\n```\n**Example:**\n```bash\ndocker tag my-app:v1.0 my-app:latest\n```\n(Now both `my-app:v1.0` and `my-app:latest` refer to the same image.)"
  },
  {
    "id": 30,
    "text": "What is Docker Content Trust?",
    "textSize": 24,
    "explanation": "Docker Content Trust (DCT) is a security feature that allows you to **verify the integrity and publisher of Docker images** using digital signatures. When enabled, Docker will only pull, push, or run images that have been signed by a trusted key, helping to prevent tampering and ensure supply chain security.\n\n**Enabling Docker Content Trust:**\n```bash\nexport DOCKER_CONTENT_TRUST=1\n```\n(Note: This is an environment variable. Operations will fail if images are not signed.)"
  },
  {
    "id": 31,
    "text": "How do you remove unused Docker objects (images, containers, volumes, networks)?",
    "textSize": 18,
    "explanation": "You can use the `docker system prune` command. This powerful command removes all stopped containers, all dangling images (images not associated with any container), all unused networks, and optionally all unused volumes (with `-v` flag). It's crucial for freeing up disk space.\n\n**Commands:**\n* **Basic prune (containers, dangling images, networks):**\n    ```bash\n    docker system prune\n    ```\n* **Prune including unused volumes:**\n    ```bash\n    docker system prune -a --volumes\n    ```\n    (The `-a` includes all unused images, not just dangling ones; `-v` or `--volumes` includes volumes.)"
  },
  {
    "id": 32,
    "text": "You want to run a simple Nginx web server in a Docker container. How would you do this, ensuring it's accessible from your machine's port 80?",
    "textSize": 18,
    "explanation": "To run an Nginx container and map its internal port 80 to your host's port 80, you use the `docker run` command with the `-p` flag.\n```bash\ndocker run -d -p 80:80 --name my-nginx-web nginx\n```\n**Explanation:**\n* `docker run`: Command to start a new container.\n* `-d`: Runs the container in detached mode (in the background).\n* `-p 80:80`: Publishes (maps) port 80 from the container to port 80 on your host machine. The format is `host_port:container_port`.\n* `--name my-nginx-web`: Assigns a human-readable name to your container.\n* `nginx`: The name of the Docker image to use."
  },
  {
    "id": 33,
    "text": "You have several Docker containers running, and some that have exited. How can you see a list of all containers, both running and stopped?",
    "textSize": 18,
    "explanation": "To list all Docker containers, including those that are currently stopped, you use the `docker ps` command with the `-a` flag.\n```bash\ndocker ps -a\n```\n**Explanation:**\n* `docker ps`: Lists only currently running containers by default.\n* `-a` or `--all`: Shows all containers, regardless of their status (running, exited, created)."
  },
  {
    "id": 34,
    "text": "You have a `Dockerfile` in your current directory to build a custom application image. How do you build this image and tag it with a meaningful name and version?",
    "textSize": 18,
    "explanation": "To build a Docker image from a `Dockerfile` in your current directory and tag it, you use the `docker build` command with the `-t` flag.\n```bash\n# Assuming your Dockerfile is in the current directory\ndocker build -t my-custom-app:1.0 .\n```\n**Explanation:**\n* `docker build`: Command to build an image from a Dockerfile.\n* `-t my-custom-app:1.0`: Tags the image with the name `my-custom-app` and version `1.0`. The format is `name:tag`.\n* `.`: Specifies the build context, which is the current directory. Docker sends all files in this directory to the Docker daemon, allowing `COPY` instructions in the Dockerfile to work."
  },
  {
    "id": 35,
    "text": "You want to remove a specific Docker container that is no longer needed. How do you do this?",
    "textSize": 18,
    "explanation": "To remove a Docker container, you use the `docker rm` command followed by the container's name or ID. If the container is running, you'll need to stop it first or force removal.\n```bash\n# First, stop the container if it's running\ndocker stop my-container-name\n\n# Then, remove the container\ndocker rm my-container-name\n\n# Or, to force removal of a running container (use with caution)\ndocker rm -f my-container-name\n```\n**Explanation:**\n* `docker stop`: Sends a SIGTERM signal to the container, allowing it to gracefully shut down.\n* `docker rm`: Removes the container from your system.\n* `-f`: (force) Kills the container immediately and then removes it."
  },
  {
    "id": 36,
    "text": "You have an old Docker image that is taking up space. How can you remove it from your local machine?",
    "textSize": 18,
    "explanation": "To remove a Docker image from your local machine, you use the `docker rmi` command followed by the image name or ID. You cannot remove an image if a container is currently using it.\n```bash\ndocker rmi my-old-image:1.0\n\n# To remove an image by ID (e.g., if multiple tags exist or no tag)\ndocker rmi 123abc456def # Replace with actual image ID\n```\n**Explanation:**\n* `docker rmi`: Removes one or more images.\n* You may need to stop and remove any containers that are based on the image first, before you can remove the image itself."
  },
  {
    "id": 37,
    "text": "How can you remove all dangling (untagged and unused) images from your system to free up space?",
    "textSize": 18,
    "explanation": "To remove all dangling images, which are layers that are not associated with any tagged images, you can use the `docker image prune` command.\n```bash\ndocker image prune\n```\n**Explanation:**\n* `docker image prune`: Removes all dangling images by default.\n* You can also use `docker system prune` to remove all unused Docker data (containers, images, volumes, networks), which is more comprehensive."
  },
  {
    "id": 38,
    "text": "You want to create a Dockerfile for a simple Python application. What are the essential instructions you'd include to copy your code and install dependencies?",
    "textSize": 18,
    "explanation": "A basic Dockerfile for a Python application would include instructions to specify a base image, set a working directory, copy application files, install dependencies, and define the command to run the application.\n\n**`Dockerfile` example:**\n```dockerfile\n# Use an official Python runtime as a parent image\nFROM python:3.9-slim-buster\n\n# Set the working directory in the container\nWORKDIR /app\n\n# Copy the current directory contents into the container at /app\nCOPY . /app\n\n# Install any needed packages specified in requirements.txt\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Make port 80 available to the world outside this container\nEXPOSE 80\n\n# Run app.py when the container launches\nCMD [\"python\", \"app.py\"]\n```"
  },
  {
    "id": 39,
    "text": "You need to inspect a running container's logs to debug an issue. How do you view the logs of a container named `my-web-app-container`?",
    "textSize": 18,
    "explanation": "To view the logs of a running Docker container, you use the `docker logs` command.\n```bash\ndocker logs my-web-app-container\n```\n**Explanation:**\n* `docker logs`: Fetches the logs of a container.\n* You can also use `docker logs -f my-web-app-container` to 'follow' the logs in real-time, similar to `tail -f`."
  },
  {
    "id": 40,
    "text": "You want to access a shell inside a running Docker container to inspect its file system or run some commands directly. How do you do that?",
    "textSize": 18,
    "explanation": "To execute a command inside a running container, often to get an interactive shell, you use the `docker exec` command.\n```bash\ndocker exec -it my-web-app-container bash\n# Or, for Alpine/BusyBox images which might not have bash:\ndocker exec -it my-web-app-container sh\n```\n**Explanation:**\n* `docker exec`: Executes a command in a running container.\n* `-it`: Combines `-i` (interactive) and `-t` (pseudo-TTY), which is necessary for an interactive shell session.\n* `my-web-app-container`: The name or ID of your running container.\n* `bash` or `sh`: The shell command you want to run inside the container."
  },
  {
    "id": 41,
    "text": "How do you persist data in a Docker container, ensuring it isn't lost when the container is removed?",
    "textSize": 18,
    "explanation": "To persist data generated by or used by a Docker container, you should use **Docker Volumes**. Volumes are the preferred mechanism for persisting data generated by and used by Docker containers, separating the storage from the container's lifecycle.\n```bash\n# Create a named volume\ndocker volume create my-app-data\n\n# Run your container, mounting the volume\ndocker run -d -p 80:80 -v my-app-data:/app/data --name my-data-app my-app-image\n```\n**Explanation:**\n* `docker volume create my-app-data`: Creates a named volume on your Docker host.\n* `-v my-app-data:/app/data`: Mounts the named volume `my-app-data` to the `/app/data` directory inside the container."
  },
  {
    "id": 42,
    "text": "You have a configuration file on your host machine that your container needs to read. How do you provide this file to the container without baking it into the image?",
    "textSize": 18,
    "explanation": "To share a host file or directory directly with a container, you can use a **bind mount**. This is useful for development or injecting configuration files at runtime.\n```bash\ndocker run -d -p 80:80 -v /path/to/my/config.conf:/etc/nginx/nginx.conf --name my-nginx-config nginx\n```\n**Explanation:**\n* `-v /path/to/my/config.conf:/etc/nginx/nginx.conf`: Creates a bind mount. The format is `host_path:container_path`. The file `config.conf` from your host machine will appear as `nginx.conf` inside the container."
  },
  {
    "id": 43,
    "text": "How do you link two containers so they can communicate with each other using their service names?",
    "textSize": 18,
    "explanation": "To enable seamless communication between containers using service names, you should create a **user-defined bridge network** and connect both containers to it.\n```bash\n# 1. Create a custom bridge network\ndocker network create my-app-network\n\n# 2. Run the database container and connect it to the network\ndocker run -d --name my-db --network my-app-network -e MYSQL_ROOT_PASSWORD=secret mysql:5.7\n\n# 3. Run the web application container and connect it to the same network\ndocker run -d --name my-web-app --network my-app-network -p 80:80 my-web-app-image\n```\n**Explanation:**\n* `docker network create`: Creates a new bridge network. Containers on the same user-defined bridge network can communicate by their container names.\n* Now, `my-web-app` container can reach the database container simply by addressing `my-db`."
  },
  {
    "id": 44,
    "text": "How can you configure a Docker container to automatically restart if it fails?",
    "textSize": 18,
    "explanation": "You can configure a container's restart policy using the `--restart` flag with `docker run`. This tells Docker how to behave when a container exits.\n```bash\ndocker run -d --name my-batch-job --restart on-failure:3 my-batch-job-image\n```\n**Explanation:**\n* `--restart on-failure:3`: This policy will restart the container only if it exits with a non-zero exit code, and it will attempt to restart a maximum of 3 times. Other policies include `no`, `always`, and `unless-stopped`."
  },
  {
    "id": 45,
    "text": "How do you force Docker to rebuild an image from scratch, ignoring the cache?",
    "textSize": 18,
    "explanation": "To force Docker to rebuild an image without using the build cache, you use the `--no-cache` flag with `docker build`.\n```bash\ndocker build --no-cache -t my-custom-app:2.0 .\n```\n**Explanation:**\n* `--no-cache`: Instructs Docker to not use the build cache. Each instruction in the Dockerfile will be executed anew, creating a fresh layer."
  },
  {
    "id": 46,
    "text": "You have a running container that is unresponsive. How do you forcefully stop it immediately?",
    "textSize": 18,
    "explanation": "To forcefully stop a running container, you use the `docker kill` command.\n```bash\ndocker kill my-unresponsive-container\n```\n**Explanation:**\n* `docker kill`: Sends a SIGKILL signal to the container, which terminates it immediately without giving it time to shut down gracefully.\n* In contrast, `docker stop` sends a SIGTERM, allowing for graceful shutdown."
  },
  {
    "id": 47,
    "text": "How do you copy files from your host machine into a running Docker container?",
    "textSize": 18,
    "explanation": "To copy files between a host and a running container, you use the `docker cp` command.\n```bash\n# Copy local_file.txt from host to /app/destination/ in container\ndocker cp local_file.txt my-container-name:/app/destination/\n\n# Copy entire_directory/ from host to /app/destination/ in container\ndocker cp entire_directory/ my-container-name:/app/destination/\n```\n**Explanation:**\n* `docker cp <source_path> <destination_path>`: The source/destination can be either a local path or a container path (specified as `container_name:/path/`)."
  },
  {
    "id": 48,
    "text": "How do you copy files from a running Docker container to your host machine?",
    "textSize": 18,
    "explanation": "Similar to copying files into a container, `docker cp` also works for copying files out of a container.\n```bash\n# Copy container_file.log from /var/log/ in container to local_destination/\ndocker cp my-container-name:/var/log/container_file.log ./local_destination/\n\n# Copy container_data/ from container to local_destination/\ndocker cp my-container-name:/app/data/container_data/ ./local_destination/\n```\n**Explanation:**\n* `docker cp <source_path> <destination_path>`: The source/destination can be either a local path or a container path. The order determines the direction of copy."
  },
  {
    "id": 49,
    "text": "How do you pass environment variables to a Docker container?",
    "textSize": 20,
    "explanation": "You can pass environment variables to a container using the `-e` or `--env` flag with `docker run`.\n```bash\ndocker run -d -p 80:80 -e APP_ENV=production -e DB_HOST=my-db --name my-env-app my-app-image\n```\n**Explanation:**\n* `-e APP_ENV=production`: Sets the `APP_ENV` environment variable inside the container to `production`.\n* You can use multiple `-e` flags to set multiple variables."
  },
  {
    "id": 50,
    "text": "How do you view the real-time resource usage of your running Docker containers?",
    "textSize": 18,
    "explanation": "To view live streaming resource usage statistics for your running containers, use `docker stats`.\n```bash\ndocker stats\n# To view stats for specific containers\ndocker stats my-container-1 my-container-2\n```\n**Explanation:**\n* `docker stats`: Provides a live stream of resource usage, including CPU percentage, memory usage, network I/O, and block I/O for all or specified running containers."
  },
  {
    "id": 51,
    "text": "How do you commit changes in a container to a new image?",
    "textSize": 20,
    "explanation": "To create a new image from the changes made in a container, you use the `docker commit` command.\n```bash\ndocker commit my-running-container my-custom-image:new-version\n```\n**Explanation:**\n* `docker commit`: Creates a new image from the changes in a container. This is generally discouraged for production workflows (prefer Dockerfiles), but useful for quick snapshots or debugging."
  },
  {
    "id": 52,
    "text": "Can you provide a Docker Command Cheatsheet?",
    "textSize": 20,
    "explanation": "Certainly! Here is a list of common Docker commands grouped by category.\n\n### Image Management\n* `docker build -t <name>:<tag> .`: Build an image from a Dockerfile.\n* `docker images` or `docker image ls`: List all local images.\n* `docker pull <image>`: Download an image from a registry.\n* `docker push <username>/<image>`: Push an image to a registry.\n* `docker rmi <image_id>`: Remove one or more images.\n* `docker tag <source> <target>`: Create a tag for a source image.\n* `docker inspect <image>`: Display detailed information on an image.\n\n### Container Management\n* `docker run <image>`: Create and start a new container from an image.\n* `docker ps`: List running containers.\n* `docker ps -a`: List all containers (running and stopped).\n* `docker start <container>`: Start one or more stopped containers.\n* `docker stop <container>`: Stop one or more running containers gracefully.\n* `docker kill <container>`: Forcibly stop a container.\n* `docker rm <container>`: Remove one or more containers.\n* `docker logs <container>`: Fetch the logs of a container.\n* `docker exec -it <container> <command>`: Execute a command in a running container.\n* `docker stats`: Display a live stream of container resource usage.\n* `docker cp <src> <dest>`: Copy files/folders between a container and the local filesystem.\n\n### Docker Compose\n* `docker compose up`: Create and start containers defined in `docker-compose.yml`.\n* `docker compose down`: Stop and remove containers, networks, and volumes.\n* `docker compose ps`: List services.\n* `docker compose logs`: View output from services.\n* `docker compose build`: Build or rebuild services.\n\n### System & Cleanup\n* `docker system prune`: Remove all unused containers, networks, and dangling images.\n* `docker system prune -a --volumes`: More aggressive cleanup, including all unused images and volumes.\n* `docker version`: Show the Docker version information.\n* `docker info`: Display system-wide information.\n* `docker login`: Log in to a Docker registry.\n* `docker logout`: Log out from a Docker registry."
  },
  {
    "id": 53,
    "text": "How do you list all running Docker containers?",
    "textSize": 20,
    "explanation": "Use `docker ps` to list all currently running containers.\n\n```bash\ndocker ps\n```\n\nTo see all containers (including stopped ones):\n```bash\ndocker ps -a\n```"
  },
  {
    "id": 54,
    "text": "How do you build a Docker image from a Dockerfile?",
    "textSize": 20,
    "explanation": "Use `docker build` command with the path to the directory containing the Dockerfile.\n\n```bash\ndocker build -t image-name:tag .\n```\n\nExample:\n```bash\ndocker build -t myapp:latest .\n```"
  },
  {
    "id": 55,
    "text": "How do you run a Docker container?",
    "textSize": 24,
    "explanation": "Use `docker run` command to create and start a new container.\n\n```bash\ndocker run image-name\n```\n\nWith common options:\n```bash\ndocker run -d -p 8080:80 --name my-container nginx\n```\n\n- `-d`: Run in detached mode\n- `-p`: Port mapping (host:container)\n- `--name`: Assign a name to the container"
  },
  {
    "id": 56,
    "text": "How do you stop and remove a Docker container?",
    "textSize": 20,
    "explanation": "To stop a running container:\n```bash\ndocker stop container-name\n```\n\nTo remove a stopped container:\n```bash\ndocker rm container-name\n```\n\nTo stop and remove in one command:\n```bash\ndocker rm -f container-name\n```"
  },
  {
    "id": 57,
    "text": "How do you view Docker container logs?",
    "textSize": 24,
    "explanation": "Use `docker logs` command to view container logs.\n\n```bash\ndocker logs container-name\n```\n\nTo follow logs in real-time:\n```bash\ndocker logs -f container-name\n```\n\nTo view last N lines:\n```bash\ndocker logs --tail 50 container-name\n```"
  },
  {
    "id": 58,
    "text": "How do you execute commands inside a running Docker container?",
    "textSize": 20,
    "explanation": "Use `docker exec` to run commands in a running container.\n\n```bash\ndocker exec -it container-name command\n```\n\nTo get an interactive shell:\n```bash\ndocker exec -it container-name /bin/bash\n```\n\nOr for Alpine-based images:\n```bash\ndocker exec -it container-name /bin/sh\n```"
  },
  {
    "id": 59,
    "text": "How do you copy files between host and Docker container?",
    "textSize": 20,
    "explanation": "Use `docker cp` to copy files between host and container.\n\n**From host to container:**\n```bash\ndocker cp /host/path/file container-name:/container/path/\n```\n\n**From container to host:**\n```bash\ndocker cp container-name:/container/path/file /host/path/\n```"
  },
  {
    "id": 60,
    "text": "How do you list and remove Docker images?",
    "textSize": 20,
    "explanation": "**List images:**\n```bash\ndocker images\n```\n\nOr:\n```bash\ndocker image ls\n```\n\n**Remove an image:**\n```bash\ndocker rmi image-name:tag\n```\n\n**Remove all unused images:**\n```bash\ndocker image prune\n```\n\n**Remove all images:**\n```bash\ndocker rmi $(docker images -q)\n```"
  },
  {
    "id": 61,
    "text": "How do you manage Docker volumes?",
    "textSize": 24,
    "explanation": "**Create a volume:**\n```bash\ndocker volume create volume-name\n```\n\n**List volumes:**\n```bash\ndocker volume ls\n```\n\n**Use volume in container:**\n```bash\ndocker run -v volume-name:/container/path image-name\n```\n\n**Remove volume:**\n```bash\ndocker volume rm volume-name\n```\n\n**Remove all unused volumes:**\n```bash\ndocker volume prune\n```"
  },
  {
    "id": 62,
    "text": "How do you clean up Docker system?",
    "textSize": 24,
    "explanation": "**Remove all stopped containers, unused networks, dangling images:**\n```bash\ndocker system prune\n```\n\n**Remove everything including unused images:**\n```bash\ndocker system prune -a\n```\n\n**Remove everything including volumes:**\n```bash\ndocker system prune -a --volumes\n```\n\n**Check disk usage:**\n```bash\ndocker system df\n```"
  }
];